// Generated by CoffeeScript 1.3.1
(function() {
  var SoundMap, sm, snd_ctx, _map;

  window.sm = sm = {};

  SoundMap = (function() {

    SoundMap.name = 'SoundMap';

    SoundMap.prototype.sound_map = {};

    function SoundMap(context, sound_map, callback) {
      var key, url, _ref;
      this.context = context;
      this.sound_map = sound_map;
      this.onload = callback;
      this.bufferList = {};
      this.loadCount = 0;
      _ref = this.sound_map;
      for (key in _ref) {
        url = _ref[key];
        this.loadBuffer(key, url);
      }
    }

    SoundMap.prototype.loadBuffer = function(key, url) {
      var loader, request;
      console.log("Key, url: " + key + ", " + url);
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      loader = this;
      request.onload = function() {
        return loader.context.decodeAudioData(request.response, function(buffer) {
          if (!buffer) {
            alert('error loading sound file: ' + url);
            return;
          }
          loader.sound_map[key] = buffer;
          if (++loader.loadCount === Object.keys(loader.sound_map).length) {
            loader.onload(loader);
          }
          return console.log("decoded " + key + ", " + loader.loadCount + " of " + (Object.keys(loader.sound_map).length) + " remaining");
        });
      };
      request.onerror = function() {
        return alert('BufferLoader: XHR error');
      };
      return request.send();
    };

    SoundMap.prototype.playSound = function(key, volume) {
      var node, source;
      if (!volume) {
        volume = .7;
      }
      node = this.context.createGainNode();
      node.gain.value = volume;
      console.log("playSound: " + key + ": " + this.sound_map[key]);
      source = this.context.createBufferSource();
      source.buffer = this.sound_map[key];
      source.connect(node);
      node.connect(this.context.destination);
      return source.noteOn(0);
    };

    return SoundMap;

  })();

  /*
  function BufferLoader(context, urlList, callback) {
    this.context = context;
    this.urlList = urlList;
    this.onload = callback;
    this.bufferList = new Array();
    this.loadCount = 0;
  }
  
  BufferLoader.prototype.loadBuffer = function(url, index) {
    // Load buffer asynchronously
    var request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";
  
    var loader = this;
  
    request.onload = function() {
      // Asynchronously decode the audio file data in request.response
      loader.context.decodeAudioData(
        request.response,
        function(buffer) {
          if (!buffer) {
            alert('error decoding file data: ' + url);
            return;
          }
          loader.bufferList[index] = buffer;
          if (++loader.loadCount == loader.urlList.length)
            loader.onload(loader.bufferList);
        }
      );
    }
  
    request.onerror = function() {
      alert('BufferLoader: XHR error');
    }
  
    request.send();
  }
  
  BufferLoader.prototype.load = function() {
    for (var i = 0; i < this.urlList.length; ++i)
    this.loadBuffer(this.urlList[i], i);
  }
  */


  sm.SoundMap = SoundMap;

  snd_ctx = new webkitAudioContext;

  _map = {
    fall: 'sound/fall.wav',
    nooo: 'sound/nooo.wav',
    hehe: 'sound/hehe.wav'
  };

  window.sounds = new SoundMap(snd_ctx, _map, function(_sound_map) {
    return console.log('loader callback!');
  });

}).call(this);
