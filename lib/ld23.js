// Generated by CoffeeScript 1.3.1
(function() {
  var Background, Bad, Dood, GRASS, Game, Hero, MOUNTAIN, SPACE, Sprite, SpriteImage, TSIZE, Tile, TitleScreen, WATER, canvas, ctx, dim, distance, game, normalize, random, sounds,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  canvas = atom.canvas;

  canvas.width = 960;

  canvas.height = 704;

  ctx = atom.context;

  atom.input.bind(atom.key.ENTER, 'select');

  atom.input.bind(atom.key.SPACE, 'begin');

  /*
  sounds = SoundMap( snd_ctx, {
      fall: 'sound/fall.wav'
      select: 'sound/select.wav'
  } )
  */


  sounds = window.sounds;

  Game = (function(_super) {

    __extends(Game, _super);

    Game.name = 'Game';

    Game.prototype.sprites = [];

    Game.prototype.doods = [];

    Game.prototype.bads = [];

    Game.prototype.timer = 15;

    Game.prototype.wave = 0;

    Game.prototype.OK = 1;

    Game.prototype.BADS = 2;

    Game.prototype.state = Game.OK;

    function Game() {
      Game.__super__.constructor.call(this);
      this.sprites = [];
      this.reset();
    }

    Game.prototype.reset = function() {
      var d, i, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.score = ['foo', 'bar'];
      this.hero = new Hero('images/hero.png');
      this.hero.x = 150;
      this.hero.y = 150;
      for (i = _i = 0; _i <= 15; i = ++_i) {
        this.doods.push(new Dood('images/dood.png', this));
      }
      _ref = this.doods;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        d = _ref[_j];
        d.x = Math.random() * 170 + canvas.width / 2;
      }
      _ref1 = this.doods;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        d = _ref1[_k];
        d.y = Math.random() * 150 + canvas.height / 2;
      }
      this.bg = new Background();
      this.bg.drop_some_tiles(.3);
      this.bg.drop_some_tiles(.3);
      this.sprites.push(this.bg);
      _ref2 = this.doods;
      for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
        d = _ref2[_l];
        this.sprites.push(d);
      }
      this.sprites.push(this.hero);
      this.timer = 5;
      this.wave = 0;
      this.state = this.OK;
      return true;
    };

    Game.prototype.update = function(dt) {
      var b, cx, cy, dude, sprite, tx, ty, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
      _ref = this.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        if (sprite !== void 0) {
          sprite.update(dt);
        }
      }
      _ref1 = this.pack_centroid(), cx = _ref1[0], cy = _ref1[1];
      _ref2 = this.doods;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        dude = _ref2[_j];
        if (!(!dude.nommed && !dude.falling)) {
          continue;
        }
        dude.move_centroid(cx, cy);
        dude.move_separation(this.doods, 3, 60);
        if (Math.random() > .7) {
          dude.pick_new_direction();
        }
        if (Math.random() > .2) {
          dude.move_separation([this.hero], 20, 200);
        }
        if (this.bads.length) {
          dude.move_separation(this.bads, 7, 130);
        }
      }
      _ref3 = this.doods;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        dude = _ref3[_k];
        if (!(!dude.falling)) {
          continue;
        }
        tx = Math.ceil(dude.x / 16);
        ty = Math.ceil(dude.y / 16);
        if (this.bg.tiles[ty][tx].val === SPACE) {
          dude.die();
          sounds.playSound('nooo', .5);
        } else if (this.bg.tiles[ty][tx].val === WATER && !dude.nommed) {
          dude.xv *= -1;
          dude.yv *= -1;
          dude.move(dt);
        }
      }
      this.last_elapsed = dt;
      this.timer -= dt;
      if (this.timer <= 0 && this.state === this.OK) {
        this.create_bads();
        this.state = this.BADS;
        this.timer = 8;
        this.wave += 1;
        this.bg.drop_some_tiles();
        return console.log("state: " + this.state);
      } else if (this.timer <= 0 && this.state === this.BADS) {
        _ref4 = this.bads;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          b = _ref4[_l];
          b.retreat();
        }
        this.state = this.OK;
        this.timer = 10;
        this.bg.drop_some_tiles();
        return sounds.playSound('fall', .3);
      }
    };

    Game.prototype.collision = function(x, y) {
      var o, _i, _len, _ref;
      _ref = this.world.collidableSprites();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        if (y > o.y - this.dh && y < o.y + o.dh && x > o.x - this.dw && x < o.x + o.dw) {
          return true;
        }
      }
      return false;
    };

    Game.prototype.create_bads = function() {
      var b, bad, i, newbads, _i, _j, _k, _len, _len1, _len2, _origin, _results;
      newbads = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = 2 * this.wave; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(new Bad('images/bad.png', this));
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = newbads.length; _i < _len; _i++) {
        bad = newbads[_i];
        _origin = this.bg.edges[Math.floor(Math.random() * (this.bg.edges.length - 1))];
        console.log(_origin);
        bad.origin = {
          x: _origin.x * 16,
          y: _origin.y * 16
        };
        bad.x = bad.origin.x;
        bad.y = bad.origin.y;
        console.log("set origin: " + bad.origin.x + ", " + bad.origin.y);
      }
      for (_j = 0, _len1 = newbads.length; _j < _len1; _j++) {
        b = newbads[_j];
        this.bads.push(b);
      }
      _results = [];
      for (_k = 0, _len2 = newbads.length; _k < _len2; _k++) {
        b = newbads[_k];
        _results.push(this.sprites.push(b));
      }
      return _results;
    };

    Game.prototype.remove_sprite = function(sprite) {
      var b, i, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      _ref = this.doods;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        b = _ref[i];
        if (b === sprite) {
          this.doods.splice(i, 1);
          console.log("removed from doods at idx " + i);
          console.log("doods left " + this.doods.length);
        }
      }
      _ref1 = this.bads;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        b = _ref1[i];
        if (b === sprite) {
          this.bads.splice(i, 1);
          console.log("removed from bads at idx " + i);
        }
      }
      _ref2 = this.sprites;
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        b = _ref2[i];
        if (b === sprite) {
          this.sprites.splice(i, 1);
          console.log("removed from sprites at idx " + i);
        }
      }
      if (this.doods.length === 0) {
        if (this.wave) {
          $('header').text("You lasted " + this.wave + " waves!");
        }
        this.stop();
        return setTimeout(function() {
          var game;
          game = new TitleScreen();
          game.run();
          window.onblur = function() {
            return game.stop();
          };
          return window.onfocus = function() {
            return game.run();
          };
        }, 0);
      }
    };

    Game.prototype.pack_centroid = function() {
      var cx, cy, dude, not_ded, summa, summay, _i, _len, _ref;
      not_ded = [];
      _ref = this.doods;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dude = _ref[_i];
        if (!(dude.falling || dude.nommed)) {
          not_ded.push(dude);
        }
      }
      summa = function(t, s) {
        return t + s.x;
      };
      summay = function(t, s) {
        return t + s.y;
      };
      cx = not_ded.reduce(summa, 0) / not_ded.length;
      cy = not_ded.reduce(summay, 0) / not_ded.length;
      return [cx, cy];
    };

    Game.prototype.draw = function() {
      var sprite, _i, _len, _ref;
      _ref = this.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        if (sprite !== void 0) {
          sprite.draw(ctx);
        }
      }
      if (this.state === this.OK) {
        $('#timer').html(this.timer.toFixed(2));
      } else {
        $('#timer').html('<b>*DANGER*</b>');
      }
      ctx.save();
      ctx.textAlign = 'left';
      ctx.font = '25px Mate SC';
      ctx.fillStyle = '#ff5c00';
      ctx.fillText("Wave #" + this.wave, 10, 30);
      this.renderDebugOverlay();
      return ctx.restore();
    };

    Game.prototype.renderDebugOverlay = function() {
      return $('#fps').html("" + (Math.round(1 / this.last_elapsed)) + " FPS");
    };

    return Game;

  })(atom.Game);

  SpriteImage = (function() {

    SpriteImage.name = 'SpriteImage';

    SpriteImage.prototype.ready = false;

    function SpriteImage(url) {
      var image,
        _this = this;
      image = new Image;
      image.src = url;
      image.onload = function() {
        return _this.ready = true;
      };
      this.image = image;
    }

    return SpriteImage;

  })();

  Sprite = (function() {

    Sprite.name = 'Sprite';

    Sprite.prototype.sx = 0;

    Sprite.prototype.sy = 0;

    Sprite.prototype.w = 0;

    Sprite.prototype.h = 0;

    Sprite.prototype.dx = 0;

    Sprite.prototype.dy = 0;

    function Sprite(spriteurl, w, h, num_frames, frame_names) {
      this.image = new SpriteImage(spriteurl);
      if (this.num_frames == null) {
        this.num_frames = num_frames;
      }
      if (this.frame_names == null) {
        this.frame_names = frame_names;
      }
    }

    Sprite.prototype.drawImage = function(ctx, sx, sy, dx, dy) {
      if (this.image.ready) {
        return ctx.drawImage(this.image.image, sx, sy, this.w, this.h, dx, dy, this.w, this.h);
      }
    };

    return Sprite;

  })();

  GRASS = 0;

  MOUNTAIN = 1;

  WATER = 2;

  SPACE = 3;

  Tile = (function(_super) {

    __extends(Tile, _super);

    Tile.name = 'Tile';

    Tile.prototype.w = 16;

    Tile.prototype.h = 16;

    Tile.prototype.anim_frames = 1;

    Tile.prototype.animating = false;

    Tile.prototype.done = false;

    function Tile(x, y, val, variety) {
      this.tx = x;
      this.ty = y;
      this.sx = variety * this.w;
      this.sy = val * this.h;
      this.val = val;
      this.image = new SpriteImage('images/tiles.png');
    }

    Tile.prototype.draw = function(ctx) {
      if (this.animating === false) {
        return this.drawImage(ctx, this.sx, this.sy, this.tx * this.w, this.ty * this.h);
      } else {
        this.drawImage(ctx, this.sx, SPACE * this.h, this.tx * this.w, this.ty * this.h);
        ctx.save();
        ctx.translate(this.tx * this.w + 8, this.ty * this.h + 8);
        ctx.scale(1 / (this.anim_frames * this.anim_frames), 1 / (this.anim_frames * this.anim_frames));
        ctx.rotate(1 - this.anim_frames);
        this.drawImage(ctx, this.sx, this.sy, -8, -8);
        ctx.restore();
        this.anim_frames += .08;
        if (this.anim_frames >= 5) {
          this.done = true;
          this.animating = false;
          this.sy = SPACE * this.h;
          return this.val = SPACE;
        }
      }
    };

    Tile.prototype.drop = function() {
      if (this.animating !== true && this.done !== true && this.val !== SPACE) {
        this.animating = true;
        this.anim_frames = 1;
        return true;
      }
      return false;
    };

    Tile.prototype.droppable = function() {
      return this.val !== SPACE && this.animating !== true;
    };

    return Tile;

  })(Sprite);

  TSIZE = 16;

  Background = (function(_super) {

    __extends(Background, _super);

    Background.name = 'Background';

    function Background() {
      var e, i, j, num_types, num_varieties, offset, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      this.edges = [];
      this.dw = canvas.width;
      this.dh = canvas.height;
      console.log("" + this.dw + " by " + this.dh);
      this.tw = this.dw / TSIZE;
      this.th = this.dh / TSIZE;
      console.log("it's " + this.tw + " by " + this.th);
      num_types = 3;
      num_varieties = 4;
      offset = {
        x: Math.random() * 40,
        y: Math.random() * 40
      };
      this.tmap = (function() {
        var _i, _ref, _results;
        _results = [];
        for (y = _i = 0, _ref = this.th; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (x = _j = 0, _ref1 = this.tw; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(this.distribute(PerlinNoise.noise((x + offset.x) / 14, (y + offset.y) / 10, 0)));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      for (i = _i = 0, _ref = this.th - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.edges.push({
          x: 0,
          y: i
        });
      }
      for (i = _j = 0, _ref1 = this.tw - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.edges.push({
          x: i,
          y: 0
        });
      }
      for (i = _k = 0, _ref2 = this.tw - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.edges.push({
          x: i,
          y: this.th - 1
        });
      }
      for (i = _l = 0, _ref3 = this.th - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        this.edges.push({
          x: this.tw - 1,
          y: i
        });
      }
      console.log("Edges: " + ((function() {
        var _len, _m, _ref4, _results;
        _ref4 = this.edges;
        _results = [];
        for (_m = 0, _len = _ref4.length; _m < _len; _m++) {
          e = _ref4[_m];
          _results.push(e.x);
        }
        return _results;
      }).call(this)));
      this.tiles = (function() {
        var _len, _m, _ref4, _results;
        _ref4 = this.tmap;
        _results = [];
        for (j = _m = 0, _len = _ref4.length; _m < _len; j = ++_m) {
          y = _ref4[j];
          _results.push((function() {
            var _len1, _n, _results1;
            _results1 = [];
            for (i = _n = 0, _len1 = y.length; _n < _len1; i = ++_n) {
              x = y[i];
              _results1.push(new Tile(i, j, x, (i + j + Math.round(Math.random() * 3)) % num_varieties));
            }
            return _results1;
          })());
        }
        return _results;
      }).call(this);
    }

    Background.prototype.draw = function(ctx) {
      var tile, tlist, _i, _len, _ref, _results;
      _ref = this.tiles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tlist = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = tlist.length; _j < _len1; _j++) {
            tile = tlist[_j];
            _results1.push(tile.draw(ctx));
          }
          return _results1;
        })());
      }
      return _results;
    };

    Background.prototype.distribute = function(noise_val) {
      if (noise_val > .70) {
        return 2;
      }
      if (noise_val > .33) {
        return 0;
      }
      return 1;
    };

    Background.prototype.drop_some_tiles = function(odds) {
      var e, edge, i, newedges, _i, _len, _ref, _results;
      if (!odds) {
        odds = .55;
      }
      _ref = this.edges;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        edge = _ref[i];
        if (Math.random() > odds && edge) {
          this.tiles[edge.y][edge.x].drop();
          newedges = [];
          if (edge.y < this.th - 1) {
            if (this.tiles[edge.y + 1][edge.x].droppable()) {
              newedges.push({
                y: edge.y + 1,
                x: edge.x
              });
            }
          }
          if (edge.y > 0) {
            if (this.tiles[edge.y - 1][edge.x].droppable()) {
              newedges.push({
                y: edge.y - 1,
                x: edge.x
              });
            }
          }
          if (edge.x < this.tw - 1) {
            if (this.tiles[edge.y][edge.x + 1].droppable()) {
              newedges.push({
                y: edge.y,
                x: edge.x + 1
              });
            }
          }
          if (edge.x > 0) {
            if (this.tiles[edge.y][edge.x - 1].droppable()) {
              newedges.push({
                y: edge.y,
                x: edge.x - 1
              });
            }
          }
          this.edges.splice(i, 1);
          i -= 1;
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = newedges.length; _j < _len1; _j++) {
              e = newedges[_j];
              _results1.push(this.edges.push(e));
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Background.prototype.update = function() {};

    Background.prototype.perlin = function(grid, size, step) {};

    return Background;

  })(Sprite);

  Dood = (function(_super) {

    __extends(Dood, _super);

    Dood.name = 'Dood';

    Dood.prototype.w = 16;

    Dood.prototype.h = 16;

    Dood.prototype.x = 0;

    Dood.prototype.y = 0;

    Dood.prototype.xv = 0;

    Dood.prototype.yv = 0;

    Dood.prototype.xf = 0;

    Dood.prototype.yf = 0;

    Dood.prototype.sx = 0;

    Dood.prototype.sy = 0;

    Dood.prototype.max_spd = 70;

    Dood.prototype.falling = false;

    Dood.prototype.fall_frame = 1;

    Dood.prototype.done = false;

    Dood.prototype.nommed = false;

    Dood.prototype.frame = 0;

    function Dood(sprite_url, world) {
      this.image = new SpriteImage(sprite_url);
      this.pick_new_direction();
      this.world = world;
      this.affinity = Math.random() * .1 + .05;
      this.nommed_by = null;
      this.frame = Math.floor(Math.random() * 8);
    }

    Dood.prototype.update = function(dt) {
      var lastxv, lastyv, _ref, _ref1;
      _ref = [this.xv, this.yv], lastxv = _ref[0], lastyv = _ref[1];
      if (Math.round(Math.random() * 10) === 1) {
        this.pick_new_direction();
      }
      if (dim([this.xv, this.yv]) > this.max_spd) {
        this.xv /= 1.4;
        this.yv /= 1.4;
      }
      this.xv -= dt;
      this.yv -= dt;
      this.move(dt);
      if (this.fall_frame >= 3) {
        this.falling_done = true;
        this.falling = false;
        this.world.remove_sprite(this);
      }
      if (this.nommed && !this.falling) {
        _ref1 = [lastxv, lastyv], this.xv = _ref1[0], this.yv = _ref1[1];
      }
      this.frame += dt * 8;
      if (this.frame > 9) {
        this.frame = 0;
      }
      return this.sx = Math.floor(this.frame) * this.w;
    };

    Dood.prototype.nom_by = function(baddie) {
      var vec_to_target, _ref;
      this.nommed = true;
      this.nommed_by = baddie.origin;
      this.max_spd = baddie.spd;
      vec_to_target = [this.nommed_by.x - this.x, this.nommed_by.y - this.y];
      _ref = normalize(vec_to_target), this.xv = _ref[0], this.yv = _ref[1];
      this.xv *= this.max_spd;
      return this.yv *= this.max_spd;
    };

    Dood.prototype.move = function(dt) {
      this.x += this.xv * dt;
      this.y += this.yv * dt;
      if (0 > this.x || this.x > (canvas.width - 16)) {
        this.xv *= -1;
        this.x += this.xv * dt;
      }
      if (0 > this.y || this.y > (canvas.height - 16)) {
        this.yv *= -1;
        return this.y += this.yv * dt;
      }
    };

    Dood.prototype.dist_from = function(other_dude) {
      if (other_dude === this) {
        return 0;
      } else {
        return distance(this.x, this.y, other_dude.x, other_dude.y);
      }
    };

    Dood.prototype.draw = function(ctx) {
      if (this.falling === false) {
        return this.drawImage(ctx, this.sx, this.sy, this.x, this.y);
      } else {
        this.drawImage(ctx, this.sx, SPACE * this.h, this.x, this.y);
        ctx.save();
        ctx.translate(this.x + 8, this.y + 8);
        ctx.scale(1 / Math.pow(this.fall_frame, 3), 1 / Math.pow(this.fall_frame, 3));
        ctx.rotate(1 - this.fall_frame);
        this.drawImage(ctx, this.sx, 0, -8, -8);
        ctx.restore();
        return this.fall_frame += .08;
      }
    };

    Dood.prototype.die = function() {
      if (!this.falling && !this.falling_done) {
        this.falling = true;
        this.falling_done = false;
        this.fall_frame = 1;
        this.xv = 0;
        return this.yv = 0;
      }
    };

    Dood.prototype.pick_new_direction = function() {
      this.xv += (Math.random() * 40) - 20;
      return this.yv += (Math.random() * 40) - 20;
    };

    Dood.prototype.move_separation = function(others, weight, max_dist) {
      var dist, other, vec, _i, _len;
      for (_i = 0, _len = others.length; _i < _len; _i++) {
        other = others[_i];
        vec = [this.x - other.x, this.y - other.y];
        dist = dim(vec);
        if (dist > max_dist) {
          return;
        }
        if (!isNaN(vec[0]) && dist !== 0) {
          this.blend_move_vec(vec, weight / dist);
        }
      }
    };

    Dood.prototype.move_centroid = function(centroidx, centroidy) {
      var vec_to_centroid;
      vec_to_centroid = [centroidx - this.x, centroidy - this.y];
      return this.blend_move_vec(vec_to_centroid, this.affinity);
    };

    Dood.prototype.blend_move_vec = function(vec, weight) {
      weight = Math.min(weight, 30);
      vec = [vec[0] * weight + this.xv, vec[1] * weight + this.yv];
      this.xv = vec[0] / (1 + weight / 2);
      return this.yv = vec[1] / (1 + weight / 2);
    };

    return Dood;

  })(Sprite);

  Hero = (function(_super) {

    __extends(Hero, _super);

    Hero.name = 'Hero';

    function Hero() {
      return Hero.__super__.constructor.apply(this, arguments);
    }

    Hero.prototype.spd = 180;

    Hero.prototype.update = function(dt) {
      var spd, v, _ref;
      if (atom.input.mouse.x && atom.input.mouse.y) {
        v = [atom.input.mouse.x - this.x, atom.input.mouse.y - this.y];
        this.blend_move_vec(v, 1);
      } else {
        return;
      }
      spd = dim([this.xv, this.yv]);
      if (spd > this.spd) {
        _ref = normalize([this.xv, this.yv]), this.xv = _ref[0], this.yv = _ref[1];
        this.xv *= this.spd;
        this.yv *= this.spd;
      }
      return this.move(dt);
    };

    return Hero;

  })(Dood);

  Bad = (function(_super) {

    __extends(Bad, _super);

    Bad.name = 'Bad';

    Bad.prototype.spd = 110;

    Bad.prototype.toggled = false;

    function Bad(sprite_url, world) {
      this.image = new SpriteImage(sprite_url);
      this.world = world;
      this.origin = {
        x: 0,
        y: 0
      };
      this.pick_target();
      this.frame = Math.floor(Math.random() * 7);
    }

    Bad.prototype.pick_target = function() {
      return this.target = this.world.doods[Math.round(Math.random() * (this.world.doods.length - 1))];
    };

    Bad.prototype.update = function(dt) {
      var spd, vec_to_target, _ref;
      if (!this.target) {
        this.pick_target();
      }
      vec_to_target = [this.target.x - this.x, this.target.y - this.y];
      this.blend_move_vec(vec_to_target, .3);
      if (!this.toggled) {
        this.move_separation([this.world.hero], 40, 170);
      }
      spd = dim([this.xv, this.yv]);
      if (spd > this.spd) {
        _ref = normalize([this.xv, this.yv]), this.xv = _ref[0], this.yv = _ref[1];
        this.xv *= this.spd;
        this.yv *= this.spd;
      }
      this.move(dt);
      this.frame += dt * 12;
      if (this.frame > 7) {
        this.frame = 0;
      }
      return this.sx = Math.floor(this.frame) * this.w;
    };

    Bad.prototype.retreat = function() {
      this.target = this.origin;
      return this.toggled = true;
    };

    Bad.prototype.move = function(dt) {
      this.x += this.xv * dt;
      this.y += this.yv * dt;
      if (Math.abs(this.x - this.target.x) < 20 && Math.abs(this.y - this.target.y) < 20) {
        if (this.toggled) {
          return this.world.remove_sprite(this);
        } else {
          console.log("caught! " + this.x + ", " + this.y + " -- " + this.target.x + ", " + this.target.y);
          sounds.playSound('hehe', .5);
          this.target.nom_by(this);
          this.target = this.origin;
          return this.toggled = true;
        }
      }
    };

    return Bad;

  })(Dood);

  distance = function(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
  };

  dim = function(vec) {
    return distance(0, 0, vec[0], vec[1]);
  };

  normalize = function(vec) {
    var _dim;
    _dim = distance(0, 0, vec[0], vec[1]);
    return [vec[0] / _dim, vec[1] / _dim];
  };

  random = function(to, from) {
    if (!from) {
      return Math.random() * to;
    }
    return Math.random() * (to - from) + from;
  };

  TitleScreen = (function(_super) {

    __extends(TitleScreen, _super);

    TitleScreen.name = 'TitleScreen';

    TitleScreen.prototype.last_wave = null;

    TitleScreen.prototype.last_score = null;

    function TitleScreen() {
      this.bg = new Background();
      this.timer = 3;
      this.time = 0;
      this.bg.drop_some_tiles(.1);
      TitleScreen.__super__.constructor.call(this);
    }

    TitleScreen.prototype.update = function(dt) {
      this.timer -= dt;
      this.time += dt;
      if (atom.input.pressed('begin')) {
        this.stop();
        sounds.playSound('fall');
        setTimeout(function() {
          var game;
          game = new Game;
          game.run();
          window.onblur = function() {
            return game.stop();
          };
          return window.onfocus = function() {
            return game.run();
          };
        }, 0);
      }
      if (this.timer <= 0) {
        this.bg.drop_some_tiles(.83);
        sounds.playSound('fall', .3);
        return this.timer = 2;
      }
    };

    TitleScreen.prototype.draw = function() {
      this.bg.draw(ctx);
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = '80px Mate SC';
      ctx.fillStyle = 'rgba(135,155,200,1)';
      ctx.textAlign = 'center';
      ctx.fillText('CRUMBLE', canvas.width / 2, 250);
      ctx.font = '25px Mate SC';
      ctx.fillStyle = 'rgba(115,125,170,1)';
      if (Math.floor(this.time * 3) % 3) {
        ctx.fillText('PRESS SPACE TO PLAY', canvas.width / 2, 300);
      }
      return ctx.restore();
    };

    return TitleScreen;

  })(atom.Game);

  game = new TitleScreen;

  game.run();

}).call(this);
